<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aglet Match: å°ç£ç™¾å’Œ Paiho Advanced</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* å‹•ç•«ç³»çµ± */
        @keyframes jellyIn { 0% { transform: scale(0); opacity: 0; } 60% { transform: scale(1.1); } 100% { transform: scale(1); opacity: 1; } }
        @keyframes powerGlow { 0%, 100% { filter: brightness(1) drop-shadow(0 0 5px gold); } 50% { filter: brightness(1.5) drop-shadow(0 0 15px gold); } }
        @keyframes knotShake { 0%, 100% { transform: rotate(0); } 25% { transform: rotate(5deg); } 75% { transform: rotate(-5deg); } }

        .item-jelly { animation: jellyIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) both; }
        .item-match { animation: scale-out-center 0.4s cubic-bezier(0.550, 0.085, 0.680, 0.530) both; }
        .item-selected { border: 3px solid #818cf8 !important; z-index: 50; transform: scale(1.05); }
        .power-up { animation: powerGlow 1.5s infinite; border-radius: 50%; border: 2px solid gold; }
        .obstacle-knot { animation: knotShake 2s infinite; opacity: 0.9; }
        .obstacle-eyelet { border: 4px inset #64748b; border-radius: 50%; background: #334155; }

        .aglet-img { width: 80%; height: 80%; object-fit: contain; pointer-events: none; }
        .glass-ui { background: rgba(15, 23, 42, 0.92); backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.1); }
        .board-container { background: radial-gradient(circle at center, #1e293b 0%, #020617 100%); position: relative; overflow: hidden; }
        #particle-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 60; }
    </style>
</head>
<body class="board-container text-slate-100 font-sans overflow-hidden">
    <canvas id="particle-canvas"></canvas>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        const GRID_SIZE = 8;
        const TYPES = ['01', '02', '03', '04', '05', '06'];
        const SPECIALS = { STRIPE: 'STRIPE', BOMB: 'BOMB', RAINBOW: 'RAINBOW' };
        const OBSTACLES = { KNOT: 'KNOT', EYELET: 'EYELET' };
        const COLORS = { '01': '#fbbf24', '02': '#94a3b8', '03': '#f472b6', '04': '#6366f1', '05': '#22c55e', '06': '#334155', 'RAINBOW': '#ffffff' };

        // --- ç²’å­ç³»çµ± (ä¿ç•™) ---
        let particles = [];
        const createParticles = (x, y, color) => {
            for (let i = 0; i < 12; i++) {
                particles.push({ x, y, color, radius: Math.random() * 3 + 1, velocity: { x: (Math.random() - 0.5) * 8, y: (Math.random() - 0.5) * 8 }, life: 1.0, decay: 0.03 });
            }
        };

        const App = () => {
            const [board, setBoard] = useState([]);
            const [score, setScore] = useState(0);
            const [moves, setMoves] = useState(30);
            const [selected, setSelected] = useState(null);
            const [isBusy, setIsBusy] = useState(false);

            // åˆå§‹åŒ–ç•«å¸ƒ
            useEffect(() => {
                const canvas = document.getElementById('particle-canvas');
                const ctx = canvas.getContext('2d');
                const animate = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    particles.forEach((p, i) => {
                        p.velocity.y += 0.15; p.x += p.velocity.x; p.y += p.velocity.y; p.life -= p.decay;
                        ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                        ctx.fillStyle = p.color + Math.floor(p.life * 255).toString(16).padStart(2, '0');
                        ctx.fill();
                        if (p.life <= 0) particles.splice(i, 1);
                    });
                    requestAnimationFrame(animate);
                };
                canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                animate();
            }, []);

            const createItem = useCallback((type = null, special = null, obstacle = null) => ({
                id: Math.random().toString(36).substr(2, 9),
                type: type || TYPES[Math.floor(Math.random() * TYPES.length)],
                special,
                obstacle
            }), []);

            const initGame = () => {
                let nb = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill());
                for(let r=0; r<GRID_SIZE; r++) {
                    for(let c=0; c<GRID_SIZE; c++) {
                        // éš¨æ©Ÿæ”¾ç½®éšœç¤™ç‰© (æ©Ÿç‡ 5%)
                        const rand = Math.random();
                        if (rand < 0.05) nb[r][c] = createItem(null, null, OBSTACLES.KNOT);
                        else if (rand < 0.1) nb[r][c] = createItem(TYPES[0], null, OBSTACLES.EYELET);
                        else {
                            let it;
                            do { it = createItem(); } while (
                                (c >= 2 && nb[r][c-1]?.type === it.type && nb[r][c-2]?.type === it.type) ||
                                (r >= 2 && nb[r-1][c]?.type === it.type && nb[r-2][c]?.type === it.type)
                            );
                            nb[r][c] = it;
                        }
                    }
                }
                setBoard(nb);
            };

            useEffect(() => { initGame(); }, []);

            const findMatches = (curr) => {
                let matchedPositions = new Set();
                let specialGenerations = [];

                // æ©«å‘æª¢ç´¢
                for (let r = 0; r < GRID_SIZE; r++) {
                    let count = 1;
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (c < GRID_SIZE - 1 && curr[r][c]?.type && curr[r][c].type === curr[r][c+1]?.type && !curr[r][c].obstacle) {
                            count++;
                        } else {
                            if (count >= 3) {
                                for (let i = 0; i < count; i++) matchedPositions.add(`${r},${c-i}`);
                                if (count === 4) specialGenerations.push({ r, c: c-Math.floor(count/2), type: SPECIALS.STRIPE, color: curr[r][c-1].type });
                                if (count >= 5) specialGenerations.push({ r, c: c-Math.floor(count/2), type: SPECIALS.RAINBOW, color: 'RAINBOW' });
                            }
                            count = 1;
                        }
                    }
                }
                // ç¸±å‘æª¢ç´¢ (ç°¡ç•¥å¯¦ä½œï¼Œé¡ä¼¼æ©«å‘)
                for (let c = 0; c < GRID_SIZE; c++) {
                    let count = 1;
                    for (let r = 0; r < GRID_SIZE; r++) {
                        if (r < GRID_SIZE - 1 && curr[r][c]?.type && curr[r][c].type === curr[r+1][c]?.type && !curr[r][c].obstacle) {
                            count++;
                        } else {
                            if (count >= 3) {
                                for (let i = 0; i < count; i++) matchedPositions.add(`${r-i},${c}`);
                                if (count === 4) specialGenerations.push({ r: r-Math.floor(count/2), c, type: SPECIALS.STRIPE, color: curr[r-1][c].type });
                            }
                            count = 1;
                        }
                    }
                }

                return {
                    positions: Array.from(matchedPositions).map(s => ({ r: +s.split(',')[0], c: +s.split(',')[1] })),
                    specials: specialGenerations
                };
            };

            const processBoard = async (curr) => {
                const { positions, specials } = findMatches(curr);
                if (positions.length === 0) { setIsBusy(false); return; }

                setIsBusy(true);
                setScore(s => s + positions.length * 50);

                // çˆ†è£‚ç‰¹æ•ˆ
                positions.forEach(p => {
                    const rect = document.getElementById(`cell-${p.r}-${p.c}`)?.getBoundingClientRect();
                    if(rect) createParticles(rect.left + rect.width/2, rect.top + rect.height/2, COLORS[curr[p.r][p.c].type] || '#fff');
                });

                await new Promise(r => setTimeout(r, 400));

                let nb = curr.map(row => row.map(cell => positions.some(p => curr[p.r][p.c] === cell) ? null : cell));
                
                // é„°è¿‘æ­»çµæ¶ˆé™¤é‚è¼¯ (Knot)
                positions.forEach(p => {
                    [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr, dc]) => {
                        const nr = p.r + dr, nc = p.c + dc;
                        if(nr >=0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE && nb[nr][nc]?.obstacle === OBSTACLES.KNOT) {
                            nb[nr][nc] = null; // è§£é–‹æ­»çµ
                        }
                    });
                });

                // ç”Ÿæˆç‰¹æ®Šé“å…·
                specials.forEach(s => { nb[s.r][s.c] = createItem(s.color, s.type); });

                // æ‰è½èˆ‡è£œå…¨
                for (let c=0; c<GRID_SIZE; c++) {
                    let empty = GRID_SIZE - 1;
                    for (let r=GRID_SIZE-1; r>=0; r--) {
                        if (nb[r][c] && !nb[r][c].obstacle) {
                            let temp = nb[r][c]; nb[r][c] = null; nb[empty][c] = temp; empty--;
                        } else if (nb[r][c]?.obstacle) { empty = r - 1; }
                    }
                    for (let r=empty; r>=0; r--) if(!nb[r][c]) nb[r][c] = createItem();
                }
                
                setBoard(nb);
                await new Promise(r => setTimeout(r, 500));
                processBoard(nb);
            };

            const onSwap = async (r1, c1, r2, c2) => {
                if (isBusy || moves <= 0) return;
                const it1 = board[r1][c1], it2 = board[r2][c2];
                if (it1.obstacle || it2.obstacle) return; // éšœç¤™ç‰©ä¸å¯äº¤æ›

                setIsBusy(true);
                let nb = board.map(row => [...row]);
                [nb[r1][c1], nb[r2][c2]] = [nb[r2][c2], nb[r1][c1]];
                setBoard(nb);
                setMoves(m => m - 1);

                const { positions } = findMatches(nb);
                if (positions.length > 0) processBoard(nb);
                else {
                    await new Promise(r => setTimeout(r, 400));
                    setBoard(board); // å½ˆå›
                    setIsBusy(false);
                }
            };

            return (
                <div className="min-h-screen flex flex-col items-center justify-center p-4">
                    {/* Header */}
                    <div className="w-full max-w-md glass-ui p-6 rounded-[2rem] mb-6 flex justify-between items-center shadow-2xl">
                        <div className="text-center"><p className="text-indigo-400 text-[10px] font-black uppercase">Score</p><p className="text-3xl font-black">{score}</p></div>
                        <div className="text-center"><h1 className="text-xl font-black italic">å°ç£ç™¾å’Œ Paiho</h1><p className="text-[9px] text-slate-500 font-bold uppercase tracking-widest">Advanced Challenge</p></div>
                        <div className="text-center"><p className="text-emerald-400 text-[10px] font-black uppercase">Moves</p><p className="text-3xl font-black">{moves}</p></div>
                    </div>

                    {/* Game Grid */}
                    <div className="glass-ui p-2 rounded-[2.5rem] relative shadow-[0_20px_50px_rgba(0,0,0,0.5)]">
                        <div className="grid gap-1.5" style={{ gridTemplateColumns: `repeat(${GRID_SIZE}, 1fr)`, width: 'min(92vw, 420px)', height: 'min(92vw, 420px)' }}>
                            {board.map((row, r) => row.map((it, c) => (
                                <div key={it?.id} id={`cell-${r}-${c}`}
                                     onClick={() => {
                                         if(!selected) setSelected({r, c});
                                         else {
                                             if(Math.abs(selected.r-r) + Math.abs(selected.c-c) === 1) onSwap(selected.r, selected.c, r, c);
                                             setSelected(null);
                                         }
                                     }}
                                     className={`flex items-center justify-center rounded-xl transition-all duration-300 w-full h-full relative
                                     ${selected?.r === r && selected?.c === c ? 'item-selected bg-white/10' : 'bg-slate-800/40'}
                                     ${it?.special ? 'power-up' : ''} ${it?.obstacle === 'KNOT' ? 'obstacle-knot bg-red-900/20' : ''}
                                     ${it?.obstacle === 'EYELET' ? 'obstacle-eyelet' : ''} item-jelly`}>
                                    
                                    {it?.obstacle === 'KNOT' ? <span className="text-xl">ğŸª¢</span> : 
                                     it?.obstacle === 'EYELET' ? <img src={`assets/${it.type}.png`} className="aglet-img opacity-50 scale-75" /> :
                                     it?.special === 'RAINBOW' ? <span className="text-2xl animate-bounce">ğŸŒˆ</span> :
                                     <img src={`assets/${it?.type}.png`} className={`aglet-img ${it?.special ? 'scale-110' : ''}`} />}
                                    
                                    {it?.special === 'STRIPE' && <div className="absolute inset-0 border-2 border-white/30 rounded-full animate-ping"></div>}
                                </div>
                            )))}
                        </div>
                    </div>
                    
                    {/* Footer */}
                    <div className="mt-8 text-center max-w-xs opacity-60">
                        <p className="text-slate-400 text-[10px] italic">
                            Featuring <span className="text-indigo-400 font-bold">å°ç£ç™¾å’Œ (Taiwan Paiho)</span> aglets and <span className="text-indigo-400 font-bold">Touch Fastener</span> tech.
                        </p>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
